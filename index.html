<!DOCTYPE html>
<html lang="id">
<head>
    <link rel="manifest" href="manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HELLIONS - Solana Seeker Edition</title>
    
    <!-- IMPORT FONT -->
    <link href="https://fonts.googleapis.com/css2?family=Knewave&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            background-color: #050505; /* Solana Dark Theme */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            touch-action: none; 
            color: white;
            user-select: none; /* Anti-select text */
            -webkit-user-select: none;
        }

        /* Container Game Skala 16:9 */
        #game-wrapper {
            position: relative;
            width: 1024px;
            height: 576px;
            transform-origin: center center;
            box-shadow: 0 0 80px rgba(153, 69, 255, 0.3); /* Solana Purple Glow */
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 4px solid #333;
            background: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #333; 
            width: 100%;
            height: 100%;
        }

        /* --- UI LAYERS --- */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .ui-layer.active {
            display: flex;
            pointer-events: auto;
        }

        /* --- HUD --- */
        #hud-layer {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            align-items: flex-start;
            z-index: 10;
            position: absolute;
            top: 0;
            width: 100%;
            pointer-events: none;
        }

        .fighter-hud {
            width: 40%;
            display: flex;
            flex-direction: column;
        }

        .bar-border {
            width: 100%; 
            height: 40px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 5px 10px rgba(0,0,0,0.9), 0 5px 15px rgba(0,0,0,0.5);
        }

        .bar-border::after {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            height: 15px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.4), rgba(255,255,255,0.05));
            border-radius: 20px;
            z-index: 2;
            pointer-events: none;
        }

        .health {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear; 
            border-radius: 20px;
        }

        #player-health { background: linear-gradient(180deg, #4facfe 0%, #00f2fe 30%, #0099c6 60%, #005f73 100%); }
        #enemy-health { background: linear-gradient(180deg, #ff7675 0%, #d63031 40%, #b71c1c 60%, #680000 100%); float: right; }

        .win-dots { display: flex; margin-top: 5px; gap: 5px; }
        .dot { width: 15px; height: 15px; background: #333; border: 2px solid #555; border-radius: 50%; transition: 0.3s; }
        .dot.active { background: #ffff00; border-color: #ffaa00; box-shadow: 0 0 10px #ffff00; transform: scale(1.2); }

        #timer {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, #444, #222);
            border: 3px solid #888;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px cyan;
        }

        /* MENUS & TEXT */
        h1 {
            font-size: 60px; margin: 0 0 30px 0;
            background: -webkit-linear-gradient(#9945FF, #14F195);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-align: center;
            text-shadow: 0px 0px 20px rgba(20, 241, 149, 0.5);
        }
        h2 { font-size: 24px; color: #fff; margin-bottom: 30px; text-align: center; }

        .menu-btn {
            background: linear-gradient(45deg, #cc0000, #8b0000);
            border: 4px solid white; color: white;
            padding: 15px 30px; font-size: 18px; cursor: pointer; margin: 10px;
            text-shadow: 2px 2px 0px black;
            image-rendering: pixelated;
            font-family: 'Press Start 2P', cursive;
        }
        .menu-btn:hover { transform: scale(1.1); box-shadow: 0 0 20px red; }

        .solana-btn {
            background: linear-gradient(45deg, #9945FF, #14F195);
            border: 2px solid white;
            margin-top: 20px;
            font-size: 14px;
            padding: 10px 20px;
        }

        .grid-container { display: flex; gap: 20px; }
        .card {
            width: 150px; height: 180px; border: 4px solid #555; background: #222;
            cursor: pointer; display: flex; flex-direction: column;
            align-items: center; justify-content: center; transition: all 0.2s;
        }
        .card img { max-width: 80%; max-height: 80px; object-fit: contain; image-rendering: pixelated; }
        .card span { margin-top: 15px; font-size: 10px; color: #aaa; text-align: center; }
        .card:hover, .card.selected { border-color: #ffcc00; background: #444; }
        
        /* OVERLAY TEXT */
        #overlay-text {
            position: absolute; top: 150px; left: 50%; transform: translateX(-50%);
            font-size: 60px; font-weight: bold; color: #ffcc00;
            text-shadow: 4px 4px 0 #cc0000, 0 0 10px yellow;
            pointer-events: none; display: none; z-index: 100;
            white-space: nowrap; text-align: center; line-height: 1.5;
            font-family: 'Press Start 2P', cursive;
        }

        #fatality-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 90px; color: #8b0000; font-family: 'Knewave', cursive;
            text-shadow: 0 0 20px red, 5px 5px 0 black;
            display: none; z-index: 101; pointer-events: none;
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-52%, -52%) rotate(-5deg); }
            75% { transform: translate(-48%, -48%) rotate(5deg); }
            100% { transform: translate(-50%, -50%) rotate(0deg); }
        }

        /* GAME OVER SCREEN */
        #game-over-screen {
            background: rgba(0,0,0,0.85);
            z-index: 30;
        }
        #game-over-title {
            font-size: 50px; color: #ffcc00; margin-bottom: 20px;
        }

        #controls-hint {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255, 0.9); font-size: 10px;
            background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 5px;
            white-space: nowrap; font-family: 'Press Start 2P', cursive; z-index: 15; line-height: 1.8;
            @media (max-width: 768px) { display: none; }
        }

        #mute-btn {
            position: absolute; bottom: 20px; left: 20px; width: 50px; height: 50px;
            background-color: rgba(0, 0, 0, 0.7); border: 3px solid white; border-radius: 5px;
            font-size: 20px; cursor: pointer; pointer-events: auto; color: white;
            display: flex; justify-content: center; align-items: center; user-select: none;
            z-index: 100; font-family: sans-serif; 
        }

        #mobile-controls {
            position: absolute; bottom: 20px; width: 100%; height: 150px;
            display: flex; justify-content: space-between; padding: 0 40px;
            box-sizing: border-box; z-index: 50; pointer-events: none;
        }
        .control-group { display: flex; gap: 20px; pointer-events: auto; align-items: center; }
        .touch-btn {
            width: 70px; height: 70px; background: rgba(255, 255, 255, 0.15);
            border: 3px solid rgba(255, 255, 255, 0.5); border-radius: 10px;
            color: white; font-size: 24px; display: flex; justify-content: center; align-items: center;
            user-select: none; touch-action: none;
            font-family: 'Press Start 2P', cursive;
        }
        .touch-btn:active { background: rgba(255, 200, 0, 0.5); }
        .action-btn { width: 80px; height: 80px; font-weight: bold; font-size: 20px; }
        .punch-btn { background: rgba(255, 50, 50, 0.2); }
        .kick-btn { background: rgba(50, 50, 255, 0.2); }
        .jump-btn { background: rgba(50, 255, 50, 0.2); font-size: 14px; } 
    </style>
</head>
<body>

    <!-- WRAPPER FOR SCALING -->
    <div id="game-wrapper">
        <div id="game-container">
            <canvas id="gameCanvas"></canvas>

            <!-- 1. MAIN MENU -->
            <div id="menu-main" class="ui-layer active" style="background: rgba(0,0,0,0.7);">
                <h1>HELLIONS</h1>
                <!-- Button IDs for JS Event Listeners (Anti-Cheat) -->
                <button id="btn-start" class="menu-btn">START GAME</button>
                <button id="btn-connect" class="menu-btn solana-btn">CONNECT WALLET</button>
            </div>

            <!-- 2. CHARACTER SELECT -->
            <div id="menu-char" class="ui-layer" style="background: rgba(0,0,0,0.85);">
                <h2>SELECT FIGHTER</h2>
                <div class="grid-container" id="char-grid"></div>
            </div>

            <!-- 3. ENEMY SELECT -->
            <div id="menu-enemy" class="ui-layer" style="background: rgba(0,0,0,0.85);">
                <h2>SELECT OPPONENT</h2>
                <div class="grid-container" id="enemy-grid"></div>
            </div>

            <!-- 4. STAGE SELECT -->
            <div id="menu-stage" class="ui-layer" style="background: rgba(0,0,0,0.85);">
                <h2>SELECT STAGE</h2>
                <div class="grid-container" id="stage-grid"></div>
            </div>

            <!-- 5. CONFIRMATION -->
            <div id="menu-confirm" class="ui-layer" style="background: rgba(0,0,0,0.7);">
                <h2>READY TO BATTLE?</h2>
                <button id="btn-fight" class="menu-btn">FIGHT!</button>
                <button id="btn-back" class="menu-btn" style="background: #333; font-size: 14px;">BACK</button>
            </div>

            <!-- 6. GAME OVER SCREEN (NEW) -->
            <div id="game-over-screen" class="ui-layer" style="display: none;">
                <h1 id="game-over-title">GAME OVER</h1>
                <button id="btn-restart" class="menu-btn">BACK TO MAIN MENU</button>
            </div>

            <div id="hud-layer" style="display: none;">
                <div class="fighter-hud">
                    <div class="bar-border"><div id="player-health" class="health"></div></div>
                    <div class="win-dots" id="player-wins">
                        <div class="dot" id="p-dot-1"></div>
                        <div class="dot" id="p-dot-2"></div>
                    </div>
                </div>
                <div id="timer">60</div>
                <div class="fighter-hud" style="align-items: flex-end;">
                    <div class="bar-border"><div id="enemy-health" class="health"></div></div>
                    <div class="win-dots" id="enemy-wins" style="flex-direction: row-reverse;">
                        <div class="dot" id="e-dot-1"></div>
                        <div class="dot" id="e-dot-2"></div>
                    </div>
                </div>
            </div>

            <div id="overlay-text">FIGHT!</div>
            <div id="fatality-text">FATALITY</div>

            <div id="controls-hint" style="display: none;">Move: A/D | Jump: Space | Punch: N | Kick: M | Fatality: N+M</div>
            <div id="mute-btn" title="Mute/Unmute">ðŸ”Š</div>
            
            <div id="mobile-controls" style="display: none;">
                <div class="control-group">
                    <div class="touch-btn" id="btn-left">â¬…</div>
                    <div class="touch-btn" id="btn-right">âž¡</div>
                </div>
                <div class="control-group">
                    <div class="touch-btn action-btn jump-btn" id="btn-jump">JUMP</div>
                    <div class="touch-btn action-btn punch-btn" id="btn-punch">N</div>
                    <div class="touch-btn action-btn kick-btn" id="btn-kick">M</div>
                </div>
            </div>
        </div>
    </div>

<script>
// IIFE untuk Enkapsulasi Variabel (ANTI-CHEAT: Menyembunyikan variabel global)
(function() {
    // --- ANTI CHEAT: Prevent Context Menu & Shortcuts ---
    document.addEventListener('contextmenu', event => event.preventDefault());
    document.addEventListener('keydown', function(e) {
        if(e.key == 'F12' || (e.ctrlKey && e.shiftKey && e.key == 'I')) {
            e.preventDefault();
        }
    });

    // --- RESPONSIVE SCALING LOGIC FOR MOBILE (FIXED TARGET) ---
    function resizeGame() {
        // Target #game-wrapper which is the parent with the fixed 16:9 ratio
        const wrapper = document.getElementById('game-wrapper');
        const targetRatio = 1024 / 576;
        const windowRatio = window.innerWidth / window.innerHeight;
        let scale;

        if (windowRatio < targetRatio) {
            scale = window.innerWidth / 1024;
        } else {
            scale = window.innerHeight / 576;
        }

        // Apply scale, keep centered
        wrapper.style.transform = `scale(${scale})`;
    }

    window.addEventListener('resize', resizeGame);
    window.addEventListener('load', resizeGame);


    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- GAME CONSTANTS ---
    canvas.width = 1024;
    canvas.height = 576;
    const GRAVITY = 0.7;
    const GROUND_HEIGHT = 96;

    // --- ASSET DATABASE ---
    const CHARACTERS = {
        'hero': {
            name: 'THE HERO',
            dims: { width: 128, height: 150 },
            offset: { x: 0, y: 25 },
            scale: 1.8,
            sprites: {
                idle: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/Sprite-0003-Sheet.png', frames: 1 },
                run: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/Sprite-0003-Sheet.png', frames: 2 },
                jump: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/jump.png', frames: 5, dims: {width: 128, height: 128}, offset: {x:0, y:0} },
                attack1: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/punch.png', frames: 2, offset: {x:0, y: 55}, hold: 25 }, 
                attack2: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/kick.png', frames: 2, hold: 25 }, 
                hit: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/hit.png', frames: 1 },
                death: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/death.png', frames: 5, offset: {x:0, y: 80} },
                
                stun: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/hero%20pusing.png', frames: 1 },
                deathFatality: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/hit.png', frames: 1, hold: 60 },
                deathBy_bonk: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/hero%20difatality%20bonk.png', frames: 4, offset: {x:0, y: 25}, hold: 60, loop: false },
                deathBy_toly: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/hero%20difatality%20toly.png', frames: 4, offset: {x:0, y: 25}, hold: 60, loop: false },
                fatality: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/hero%20fatality.png', frames: 4, offset: {x:0, y: 25}, hold: 50, loop: false },
                
                win: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/win.png', frames: 4, hold: 20 }
            }
        },
        'punk': {
            name: 'THE PUNK',
            dims: { width: 128, height: 128 },
            offset: { x: 0, y: 25 },
            scale: 1.8,
            sprites: {
                idle: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/punk.png', frames: 1 },
                run: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/enemy%20walk.png', frames: 2 },
                jump: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/enemy%20jump.png', frames: 4 },
                attack1: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/enemy%20punch.png', frames: 2, hold: 25 },
                attack2: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/enemy%20kick.png', frames: 2, hold: 25 },
                hit: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/enemy%20hit.png', frames: 2 },
                death: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/enemy%20death.png', frames: 6 },
                
                stun: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/punk%20pusing.png', frames: 1 },
                deathFatality: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/enemy%20hit.png', frames: 2, hold: 60 },
                deathBy_bonk: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/punk%20difatality%20bonk.png', frames: 4, offset: {x:0, y: 25}, hold: 60, loop: false },
                deathBy_toly: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/punk%20difatality%20toly.png', frames: 4, offset: {x:0, y: 25}, hold: 60, loop: false },
                fatality: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/punk%20fatality.png', frames: 4, offset: {x: 0, y: 25}, hold: 50, loop: false },
                win: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/enemy%20win.png', frames: 5, hold: 20 }
            }
        },
        'toly': {
            name: 'TOLY',
            dims: { width: 128, height: 128 },
            offset: { x: 0, y: 25 },
            scale: 1.8,
            profile: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/ttl.jpg',
            sprites: {
                idle: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/toly.png', frames: 1 },
                run: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/twalk.png', frames: 2 },
                jump: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/tjump.png', frames: 3 },
                attack1: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/tpunch.png', frames: 2, hold: 25 },
                attack2: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/tkick.png', frames: 2, hold: 25 },
                hit: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/thit.png', frames: 2 },
                death: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/tko.png', frames: 4, offset: {x: 0, y: 25}, hold: 60 }, 
                
                stun: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/toly%20pusing.png', frames: 1 },
                deathFatality: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/thit.png', frames: 2, hold: 60 },
                deathBy_bonk: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/toly%20difatality%20bonk.png', frames: 4, offset: {x:0, y: 25}, hold: 60, loop: false },
                deathBy_toly: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/toly%20difatality%20toly.png', frames: 4, offset: {x:0, y: 25}, hold: 60, loop: false },
                fatality: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/toly%20fatality.png', frames: 4, offset: {x: 0, y: 25}, hold: 50, loop: false },
                win: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/twin.png', frames: 4, hold: 20 }
            }
        },
        'bonk': {
            name: 'BONK',
            dims: { width: 128, height: 128 },
            offset: { x: 0, y: 25 },
            scale: 1.8,
            profile: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/ttl2.jpg',
            sprites: {
                idle: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20idle.png', frames: 1 }, 
                run: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20walk.png', frames: 2 },
                jump: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20jump.png', frames: 4 },
                attack1: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20punch.png', frames: 2, hold: 25 },
                attack2: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20kick.png', frames: 2, hold: 25 },
                hit: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20hit.png', frames: 2 },
                death: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20death.png', frames: 4, offset: {x: 0, y: 25}, hold: 60 },
                
                stun: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20pusing.png', frames: 1 },
                deathFatality: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20hit.png', frames: 2, hold: 60 },
                deathBy_bonk: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20difatality%20bonk.png', frames: 4, offset: {x:0, y: 25}, hold: 60, loop: false },
                deathBy_toly: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20difatality%20toly.png', frames: 4, offset: {x:0, y: 25}, hold: 60, loop: false },
                fatality: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20fatality.png', frames: 4, offset: {x: 0, y: 25}, hold: 50, loop: false },
                win: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20win.png', frames: 4, hold: 20 },
                start: { src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bonk%20start.png', frames: 4, hold: 50 }
            }
        }
    };

    const STAGES = {
        'city': { name: 'NEON CITY', src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/bg%20final.png', frames: 2, dims: {width: 700, height: 400} },
        'alley': { name: 'BACK ALLEY', src: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/jan.png', frames: 2, dims: {width: 700, height: 400} }
    };

    // --- AUDIO ---
    const AUDIO = {
        music: new Audio('https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/Neon%20Back%20Alley%20Run.mp3'),
        swing: new Audio('https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/no%20hit.mp3'),
        hitP: new Audio('https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/punch%20s.mp3'),
        hitK: new Audio('https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/kick%20s.mp3'),
        ko: new Audio('https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/ko.wav'),
        voiceP: new Audio('https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/man%20voice.wav'),
        voiceE: new Audio('https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/man%20voice%202.wav'),
        readyFight: new Audio('https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/Ready%20Fight!%20Sound%20Effect.mp3'),
        finishHim: new Audio('https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/FINISH%20HIM%20_%20Sound%20Effect.mp3'),
        fatalityTheme: new Audio('https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/Mortal%20Kombat%201%20Fatality%20Theme%20(mp3cut.net).mp3')
    };
    AUDIO.music.loop = true;
    AUDIO.music.volume = 0.5;

    function playSound(audio) {
        if (!AUDIO.music.muted) {
            const clone = audio.cloneNode(); 
            clone.volume = 0.7; 
            clone.play().catch(e => {}); 
        }
    }

    // --- GAME STATE VARIABLES ---
    let gameState = 'MENU'; 
    let playerSelection = 'hero';
    let enemySelection = 'punk';
    let stageSelection = 'city';
    
    let player, enemy, gameBackground, crow;
    let timer = 60;
    let timerId;
    let koSoundPlayed = false;
    let finishHimTimer; 

    // ROUND SYSTEM
    let playerWins = 0;
    let enemyWins = 0;
    let currentRound = 1;
    let finishHimActive = false; 
    let fatalityPerformed = false; 

    const keys = { 
        d: { pressed: false }, 
        a: { pressed: false },
        n: { pressed: false },
        m: { pressed: false }
    };

    function showLayer(id) {
        document.querySelectorAll('.ui-layer').forEach(el => el.classList.remove('active'));
        if(id) document.getElementById(id).classList.add('active');
    }

    // --- EVENT LISTENERS FOR BUTTONS (ANTI-CHEAT: JS Bound) ---
    document.getElementById('btn-start').addEventListener('click', goToCharSelect);
    document.getElementById('btn-fight').addEventListener('click', startMatch);
    document.getElementById('btn-back').addEventListener('click', resetMenu);
    document.getElementById('btn-restart').addEventListener('click', resetMenu);

    function generateGrid(containerId, data, onClickFn) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';
        for (const [key, val] of Object.entries(data)) {
            const card = document.createElement('div');
            card.className = 'card';
            let imgSrc;
            if (val.profile) {
                imgSrc = val.profile;
            } else if (val.sprites) {
                imgSrc = val.sprites.idle ? val.sprites.idle.src : val.sprites.start.src;
            } else {
                imgSrc = val.src;
            }
            card.innerHTML = `<img src="${imgSrc}"><span>${val.name}</span>`;
            card.onclick = () => {
                Array.from(container.children).forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                onClickFn(key);
            };
            container.appendChild(card);
        }
        if(container.children.length > 0) container.children[0].click();
    }

    function goToCharSelect() {
        if(AUDIO.music.paused) AUDIO.music.play().catch(e=>{});
        generateGrid('char-grid', CHARACTERS, (key) => playerSelection = key);
        showLayer('menu-char');
        let btn = document.getElementById('char-next-btn');
        if(!btn) {
            btn = document.createElement('button');
            btn.id = 'char-next-btn';
            btn.className = 'menu-btn';
            btn.innerText = 'NEXT >>';
            btn.onclick = goToEnemySelect;
            document.getElementById('menu-char').appendChild(btn);
        }
    }

    function goToEnemySelect() {
        generateGrid('enemy-grid', CHARACTERS, (key) => enemySelection = key);
        showLayer('menu-enemy');
        let btn = document.getElementById('enemy-next-btn');
        if(!btn) {
            btn = document.createElement('button');
            btn.id = 'enemy-next-btn';
            btn.className = 'menu-btn';
            btn.innerText = 'NEXT >>';
            btn.onclick = goToStageSelect;
            document.getElementById('menu-enemy').appendChild(btn);
        }
    }

    function goToStageSelect() {
        generateGrid('stage-grid', STAGES, (key) => stageSelection = key);
        showLayer('menu-stage');
        let btn = document.getElementById('stage-next-btn');
        if(!btn) {
            btn = document.createElement('button');
            btn.id = 'stage-next-btn';
            btn.className = 'menu-btn';
            btn.innerText = 'NEXT >>';
            btn.onclick = () => showLayer('menu-confirm');
            document.getElementById('menu-stage').appendChild(btn);
        }
    }

    function resetMenu() {
        // Reset full game state
        gameState = 'MENU';
        playerWins = 0;
        enemyWins = 0;
        currentRound = 1;
        updateWinIndicators();
        // Hide overlays
        document.getElementById('overlay-text').style.display = 'none';
        document.getElementById('fatality-text').style.display = 'none';
        document.getElementById('game-over-screen').style.display = 'none'; 
        
        showLayer('menu-main');
        
        AUDIO.fatalityTheme.pause();
        AUDIO.fatalityTheme.currentTime = 0;
        if(!AUDIO.music.muted) AUDIO.music.play().catch(e=>{});
    }

    function startMatch() {
        playerWins = 0;
        enemyWins = 0;
        currentRound = 1;
        updateWinIndicators();
        showLayer(null); 
        initGameObjects(); 
        document.getElementById('hud-layer').style.display = 'flex';
        document.getElementById('controls-hint').style.display = 'block';
        document.getElementById('mobile-controls').style.display = 'flex';
        resizeGame(); 
        startBattleSequence();
        
        if(!AUDIO.music.muted) AUDIO.music.play().catch(e=>{});
    }

    function startBattleSequence() {
        player.health = 100;
        enemy.health = 100;
        player.dead = false;
        enemy.dead = false;
        koSoundPlayed = false;
        finishHimActive = false; 
        fatalityPerformed = false; 
        
        timer = 60;
        document.getElementById('timer').innerHTML = timer;
        document.getElementById('fatality-text').style.display = 'none'; 
        document.getElementById('overlay-text').style.display = 'none';
        document.getElementById('game-over-screen').style.display = 'none';

        document.querySelector('#player-health').style.width = '100%';
        document.querySelector('#enemy-health').style.width = '100%';
        
        player.position.x = 200;
        enemy.position.x = 800;

        // FORCE RESET ANIMATION STATE
        player.image = player.sprites.idle.image;
        player.framesCurrent = 0;
        player.isAttacking = false;
        player.framesHold = 10;
        player.frameDims = player.sprites.idle.frameDims || player.defaultDims;

        enemy.image = enemy.sprites.idle.image;
        enemy.framesCurrent = 0;
        enemy.isAttacking = false;
        enemy.framesHold = 10;
        enemy.frameDims = enemy.sprites.idle.frameDims || enemy.defaultDims;
        
        keys.a.pressed = false;
        keys.d.pressed = false;
        keys.n.pressed = false;
        keys.m.pressed = false;
        
        if (player.sprites.start) player.switchSprite('start'); 
        if (enemy.sprites.start) enemy.switchSprite('start');

        playSound(AUDIO.readyFight);
        
        if (!AUDIO.music.muted) AUDIO.music.play().catch(e=>{});

        gameState = 'PRE_FIGHT';
        const overlay = document.getElementById('overlay-text');
        overlay.style.display = 'block';
        
        let roundText = "ROUND " + currentRound;
        if (currentRound === 3) roundText = "FINAL ROUND";

        overlay.innerHTML = `<div style="font-size: 40px; color: white;">${roundText}</div>FIGHT!`; 
        overlay.style.fontSize = "60px";
        overlay.style.color = "#ffcc00"; 
        
        setTimeout(() => {
            overlay.style.display = 'none';
            gameState = 'PLAY';
            decreaseTimer();
        }, 2000);
    }

    function updateWinIndicators() {
        const pDots = document.getElementById('player-wins').children;
        const eDots = document.getElementById('enemy-wins').children;
        pDots[0].className = playerWins >= 1 ? 'dot active' : 'dot';
        pDots[1].className = playerWins >= 2 ? 'dot active' : 'dot';
        eDots[0].className = enemyWins >= 1 ? 'dot active' : 'dot';
        eDots[1].className = enemyWins >= 2 ? 'dot active' : 'dot';
    }

    function initGameObjects() {
        const pConfig = CHARACTERS[playerSelection];
        const eConfig = CHARACTERS[enemySelection];
        const sConfig = STAGES[stageSelection];

        gameBackground = new Background({
            imageSrc: sConfig.src,
            framesMax: sConfig.frames,
            frameDims: sConfig.dims,
            framesHold: 40
        });

        crow = new Crow({
            position: { x: canvas.width + 100, y: 120 },
            velocity: { x: -2, y: 0 }
        });

        player = new Fighter({
            id: playerSelection,
            position: { x: 200, y: 0 },
            velocity: { x: 0, y: 0 },
            imageSrc: pConfig.sprites.idle.src,
            framesMax: pConfig.sprites.idle.frames,
            scale: pConfig.scale,
            offset: pConfig.offset,
            sprites: mapSprites(pConfig.sprites),
            frameDims: pConfig.dims
        });

        enemy = new Fighter({
            id: enemySelection,
            position: { x: 800, y: 0 },
            velocity: { x: 0, y: 0 },
            imageSrc: eConfig.sprites.idle.src,
            framesMax: eConfig.sprites.idle.frames,
            scale: eConfig.scale,
            offset: eConfig.offset,
            sprites: mapSprites(eConfig.sprites),
            frameDims: eConfig.dims,
            isEnemy: true
        });
    }

    function mapSprites(spriteConfig) {
        const mapped = {};
        for(const [key, val] of Object.entries(spriteConfig)) {
            mapped[key] = {
                imageSrc: val.src,
                framesMax: val.frames,
                framesHold: val.hold || 10,
                frameDims: val.dims, 
                offset: val.offset,
                loop: val.loop !== undefined ? val.loop : true
            };
        }
        return mapped;
    }

    class Sprite {
        constructor({ position, imageSrc, scale = 1, framesMax = 1, offset = {x: 0, y: 0}, frameDims = {width: 128, height: 150}, framesHold = 10, loop = true }) {
            this.position = position;
            this.width = 50;
            this.height = 150;
            this.image = new Image();
            this.image.src = imageSrc;
            this.scale = scale;
            this.framesMax = framesMax;
            this.framesCurrent = 0;
            this.framesElapsed = 0;
            this.framesHold = framesHold;
            this.offset = offset;
            this.frameDims = frameDims; 
            this.loop = loop;
        }

        draw() {
            if (!this.image) return;
            ctx.drawImage(
                this.image,
                this.framesCurrent * this.frameDims.width,
                0,
                this.frameDims.width,
                this.frameDims.height,
                this.position.x - this.offset.x,
                this.position.y - this.offset.y,
                this.frameDims.width * this.scale,
                this.frameDims.height * this.scale
            );
        }

        animateFrames() {
            this.framesElapsed++;
            if (this.framesElapsed % this.framesHold === 0) {
                if (this.framesCurrent < this.framesMax - 1) {
                    this.framesCurrent++;
                } else if (this.loop) {
                    this.framesCurrent = 0;
                }
            }
        }

        update() {
            this.draw();
            this.animateFrames();
        }
    }

    class Background extends Sprite {
        constructor({ imageSrc, framesMax = 1, framesHold = 20, frameDims }) {
            super({ position: {x: 0, y: 0}, imageSrc, framesMax, framesHold, frameDims });
        }
        draw() {
            if (!this.image.width) return;
            const scale = Math.max(canvas.width / this.frameDims.width, canvas.height / this.frameDims.height);
            const newWidth = this.frameDims.width * scale;
            const newHeight = this.frameDims.height * scale;
            const x = (canvas.width - newWidth) / 2;
            const y = (canvas.height - newHeight) / 2;
            ctx.drawImage(this.image, this.framesCurrent * this.frameDims.width, 0, this.frameDims.width, this.frameDims.height, x, y, newWidth, newHeight);
        }
        update() { this.draw(); this.animateFrames(); }
    }

    class Crow extends Sprite {
        constructor({ position, velocity }) {
            super({ position, imageSrc: 'https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/crow.png', scale: 1, framesMax: 2, frameDims: { width: 64, height: 64 }, framesHold: 8 });
            this.velocity = velocity;
        }
        update() {
            this.position.x += this.velocity.x;
            if (this.position.x + (this.frameDims.width * this.scale) < 0) {
                this.position.x = canvas.width + 100;
                this.position.y = Math.random() * 200 + 50; 
            }
            this.draw();
            this.animateFrames();
        }
    }

    class Fighter extends Sprite {
        constructor({ id, position, velocity, imageSrc, scale = 1, framesMax = 1, offset = {x: 0, y: 0}, sprites, frameDims, isEnemy = false }) {
            super({ position, imageSrc, scale, framesMax, offset, frameDims });
            this.id = id;
            this.velocity = velocity;
            this.width = 50; this.height = 150; 
            this.lastKey;
            this.isEnemy = isEnemy;
            this.health = 100;
            this.isAttacking = false;
            this.attackType = 'attack1';
            this.facing = isEnemy ? -1 : 1;
            this.dead = false;
            this.hasLanded = false; 
            this.currentOffset = offset;
            this.sprites = sprites;
            this.defaultDims = frameDims;

            for (const sprite in this.sprites) {
                this.sprites[sprite].image = new Image();
                this.sprites[sprite].image.src = this.sprites[sprite].imageSrc;
            }

            this.attackBox = {
                position: { x: this.position.x, y: this.position.y },
                offset: { x: 0, y: 50 },
                width: 100, height: 50
            };
        }

        takeHit() { 
            if (this.dead || this.health <= 0) return;
            this.switchSprite('hit'); 
        }

        jump() {
            if (this.position.y + this.height >= canvas.height - GROUND_HEIGHT && !this.dead && !this.isAttacking && this.image !== this.sprites.hit.image) {
                this.velocity.y = -20; 
            }
        }

        attack(type) {
            if (this.image === this.sprites.hit.image || this.image === this.sprites.death.image || (this.sprites.win && this.image === this.sprites.win.image)) return;
            
            if (this.isAttacking && type !== 'fatality') return;
            
            this.isAttacking = true;
            this.velocity.x = 0; 
            this.attackType = type; 

            playSound(AUDIO.swing);
            if (!this.isEnemy) playSound(AUDIO.voiceP); 
            else playSound(AUDIO.voiceE);

            if (type === 'attack1') { 
                this.attackBox.width = 100; this.attackBox.height = 50; 
                this.switchSprite('attack1'); 
            } else if (type === 'attack2') { 
                this.attackBox.width = 140; this.attackBox.height = 40; 
                this.switchSprite('attack2'); 
            } else if (type === 'fatality') {
                 if (this.sprites.fatality) {
                     this.switchSprite('fatality');
                 } else {
                     this.switchSprite('attack1');
                 }
            }
        }

        switchSprite(sprite) {
            if (!this.sprites[sprite]) return;

            // Handle specific death sprites like deathBy_bonk
            if (sprite.startsWith('deathBy_') && !this.sprites[sprite]) {
                 sprite = 'death';
            }

            if (this.image === this.sprites.death.image || (this.sprites.deathFatality && this.image === this.sprites.deathFatality.image)) {
                if (this.framesCurrent === this.sprites[sprite].framesMax - 1) this.dead = true;
                return;
            }

            // FORCE DEATH LOGIC
            if (sprite === 'death' || sprite.startsWith('deathBy_')) {
                 if (this.image !== this.sprites[sprite].image) {
                    this.image = this.sprites[sprite].image;
                    this.framesMax = this.sprites[sprite].framesMax;
                    this.framesHold = this.sprites[sprite].framesHold || 10;
                    this.frameDims = this.sprites[sprite].frameDims || this.defaultDims;
                    this.offset = this.sprites[sprite].offset || this.currentOffset;
                    this.loop = this.sprites[sprite].loop !== undefined ? this.sprites[sprite].loop : false; 
                    this.framesCurrent = 0;
                 }
                 return;
            }
            
            // STUN LOGIC
            if (sprite === 'stun') {
                 if (this.image !== this.sprites.stun.image) {
                    this.image = this.sprites.stun.image;
                    this.framesMax = this.sprites.stun.framesMax;
                    this.framesHold = 60; 
                    this.frameDims = this.sprites.stun.frameDims || this.defaultDims;
                    this.offset = this.sprites.stun.offset || this.currentOffset;
                    this.loop = true; 
                    this.framesCurrent = 0;
                 }
                 return;
            }

            if (this.sprites.win && this.image === this.sprites.win.image) return;
            if (this.image === this.sprites.hit.image && this.framesCurrent < this.sprites.hit.framesMax - 1) return;
            if (this.image === this.sprites.attack1.image && this.framesCurrent < this.sprites.attack1.framesMax - 1) return;
            if (this.image === this.sprites.attack2.image && this.framesCurrent < this.sprites.attack2.framesMax - 1) return;
            if (this.sprites.start && this.image === this.sprites.start.image && this.framesCurrent < this.sprites.start.framesMax - 1) return;

            if (this.image !== this.sprites[sprite].image) {
                this.image = this.sprites[sprite].image;
                this.framesMax = this.sprites[sprite].framesMax;
                this.framesHold = this.sprites[sprite].framesHold || 10;
                this.frameDims = this.sprites[sprite].frameDims || this.defaultDims;
                this.offset = this.sprites[sprite].offset || this.currentOffset;
                this.loop = (this.sprites[sprite].loop !== undefined) ? this.sprites[sprite].loop : true;
                this.framesCurrent = 0; 
            }
        }

        draw() {
            ctx.save();
            let shouldFlip = (this.facing === 1);
            
            if (this.image.src.includes('bonk')) {
                 shouldFlip = !shouldFlip;
            } else if (this.image === this.sprites.attack2.image) {
                 const src = this.image.src;
                 if (src.includes('kick.png') && !src.includes('enemy') && !src.includes('tkick')) {
                      shouldFlip = !shouldFlip;
                 }
            }

            if (shouldFlip) { 
                ctx.translate(this.position.x + this.width / 2, this.position.y + this.height / 2);
                ctx.scale(-1, 1);
                ctx.translate(-(this.position.x + this.width / 2), -(this.position.y + this.height / 2));
            }

            const scaledWidth = this.frameDims.width * this.scale;
            const scaledHeight = this.frameDims.height * this.scale;
            const drawX = this.position.x - (scaledWidth - this.width) / 2 - this.offset.x;
            const drawY = (this.position.y - (scaledHeight - this.height)) + this.offset.y;

            if (!this.dead) {
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                const groundY = canvas.height - GROUND_HEIGHT;
                const heightFromGround = (groundY - (this.position.y + this.height));
                let shadowSize = 40 - (Math.max(0, heightFromGround) / 5);
                shadowSize = Math.max(10, shadowSize);
                ctx.ellipse(this.position.x + this.width/2, groundY + 10, shadowSize, 10, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            if (this.image) {
                ctx.drawImage(
                    this.image,
                    this.framesCurrent * this.frameDims.width, 
                    0, this.frameDims.width, this.frameDims.height,                     
                    drawX, drawY, scaledWidth, scaledHeight         
                );
            }
            ctx.restore();

            if (this.isAttacking) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.0)'; 
                let attackX = this.facing === 1 
                    ? this.position.x + this.width 
                    : this.position.x - this.attackBox.width;
                ctx.fillRect(attackX, this.attackBox.position.y, this.attackBox.width, this.attackBox.height);
            }
        }

        update() {
            this.draw();
            
            // Death No Loop logic
            if (this.image === this.sprites.death.image || (this.sprites.deathFatality && this.image === this.sprites.deathFatality.image) || (this.image.src.includes('difatality'))) {
                this.velocity.x = 0; 
                this.framesElapsed++;
                if (this.framesElapsed % this.framesHold === 0) {
                    if (this.framesCurrent < this.framesMax - 1) {
                        this.framesCurrent++;
                    }
                }
            } 
            else if (this.sprites.win && this.image === this.sprites.win.image) {
                this.framesElapsed++;
                if (this.framesElapsed % this.framesHold === 0) {
                    if (this.framesCurrent < this.framesMax - 1) {
                        this.framesCurrent++;
                    }
                }
                return;
            }
            else if (this.sprites.start && this.image === this.sprites.start.image) {
                 this.framesElapsed++;
                 if (this.framesElapsed % this.framesHold === 0) {
                    if (this.framesCurrent < this.framesMax - 1) {
                        this.framesCurrent++;
                    } else {
                        this.switchSprite('idle'); 
                    }
                }
                this.velocity.x = 0;
            } 
            else if (this.sprites.fatality && this.image === this.sprites.fatality.image) {
                 this.velocity.x = 0;
                 this.framesElapsed++;
                 if (this.framesElapsed % this.framesHold === 0) {
                    if (this.framesCurrent < this.framesMax - 1) {
                        this.framesCurrent++;
                    } else {
                         // Fatality anim done -> Win pose
                         this.switchSprite('win');
                    }
                }
            }
            else if (this.sprites.stun && this.image === this.sprites.stun.image) {
                this.velocity.x = 0; 
                this.framesElapsed++;
                 if (this.framesElapsed % this.framesHold === 0) {
                     if (this.framesCurrent < this.framesMax - 1) {
                         this.framesCurrent++;
                     } else {
                         this.framesCurrent = 0;
                     }
                 }
            }
            else {
                this.framesElapsed++;
                if (this.framesElapsed % this.framesHold === 0) {
                    if (this.framesCurrent < this.framesMax - 1) {
                        this.framesCurrent++;
                    } else {
                        if (this.image === this.sprites.hit.image || this.isAttacking) {
                            this.isAttacking = false;
                            this.switchSprite('idle');
                        } else {
                            this.framesCurrent = 0;
                        }
                    }
                }
            }
            
            this.attackBox.position.x = this.position.x + this.attackBox.offset.x;
            this.attackBox.position.y = this.position.y + 20;
            this.position.x += this.velocity.x;
            this.position.y += this.velocity.y;

            if (this.position.y + this.height + this.velocity.y >= canvas.height - GROUND_HEIGHT) {
                this.velocity.y = 0;
                this.position.y = canvas.height - GROUND_HEIGHT - this.height;

                if (!this.hasLanded) {
                    this.hasLanded = true;
                    if (this.sprites.start) {
                        this.switchSprite('start');
                    }
                }
            } else {
                this.velocity.y += GRAVITY;
            }
            if (this.position.x < 0) this.position.x = 0;
            if (this.position.x + this.width > canvas.width) this.position.x = canvas.width - this.width;
        }
    }

    function rectangularCollision({ rectangle1, rectangle2 }) {
        let attackX = rectangle1.facing === 1 ? rectangle1.position.x + rectangle1.width : rectangle1.position.x - rectangle1.attackBox.width;
        return (
            attackX + rectangle1.attackBox.width >= rectangle2.position.x &&
            attackX <= rectangle2.position.x + rectangle2.width &&
            rectangle1.attackBox.position.y + rectangle1.attackBox.height >= rectangle2.position.y &&
            rectangle1.attackBox.position.y <= rectangle2.position.y + rectangle2.height
        );
    }

    function determineWinner({ player, enemy, timerId }) {
        clearTimeout(timerId);
        gameState = 'ROUND_OVER'; 
        
        let roundWinner = null;

        if (player.health > enemy.health) {
            playerWins++;
            roundWinner = "PLAYER";
            if (!fatalityPerformed) player.switchSprite('win');
        } else if (enemy.health > player.health) {
            enemyWins++;
            roundWinner = "ENEMY";
            if (!fatalityPerformed) enemy.switchSprite('win');
        } else {
            roundWinner = "DRAW";
        }
        
        updateWinIndicators(); 

        const overlay = document.getElementById('overlay-text');
        
        if (playerWins >= 2 || enemyWins >= 2) {
             let msg = (playerWins >= 2) ? "YOU WIN THE MATCH!" : "YOU LOSE";
             if(playerWins === 2 && enemyWins === 2) msg = "DRAW GAME"; 

             let delay = fatalityPerformed ? 2000 : 1000;
             setTimeout(() => {
                document.getElementById('game-over-screen').style.display = 'flex';
                document.getElementById('game-over-title').innerText = msg;
                gameState = 'GAMEOVER'; 
             }, delay);

        } else {
             overlay.style.display = 'block';
             overlay.innerHTML = `${roundWinner} WINS ROUND ${currentRound}`;
             overlay.style.fontSize = "50px";
             overlay.style.color = "#ffcc00";

             setTimeout(() => {
                 currentRound++;
                 startBattleSequence(); 
             }, 3000); 
        }
    }

    function triggerFinishHim() {
        if(finishHimActive) return;
        finishHimActive = true;
        const overlay = document.getElementById('overlay-text');
        overlay.style.display = 'block';
        overlay.innerText = "FINISH HIM!";
        overlay.style.color = "red";
        overlay.style.fontSize = "80px";
        playSound(AUDIO.finishHim); 
        clearTimeout(timerId);
        
        if (player.health <= 0) player.switchSprite('stun');
        else if (enemy.health <= 0) enemy.switchSprite('stun');
        
        finishHimTimer = setTimeout(() => {
             determineWinner({ player, enemy, timerId });
             gameState = 'ROUND_OVER';
             finishHimActive = false;
        }, 5000);
    }
    
    function performFatality(winner, loser) {
        clearTimeout(finishHimTimer);
        fatalityPerformed = true; 

        AUDIO.music.pause();
        AUDIO.music.currentTime = 0;

        if (!AUDIO.music.muted) {
             AUDIO.fatalityTheme.currentTime = 0;
             AUDIO.fatalityTheme.volume = 0.8;
             AUDIO.fatalityTheme.play().catch(e=>{});
        }

        document.getElementById('overlay-text').style.display = 'none';

        document.getElementById('fatality-text').style.display = 'block';
        document.body.style.backgroundColor = 'red'; 
        setTimeout(() => document.body.style.backgroundColor = '#050505', 100);
        
        loser.switchSprite('deathBy_' + winner.id); 
        loser.dead = true;
        winner.switchSprite('fatality'); 

        setTimeout(() => {
            determineWinner({ player, enemy, timerId }); 
            document.getElementById('fatality-text').style.display = 'none';
        }, 3000);
    }

    function decreaseTimer() {
        if (timer > 0 && gameState === 'PLAY' && !finishHimActive) {
            timerId = setTimeout(decreaseTimer, 1000);
            timer--;
            document.getElementById('timer').innerHTML = timer;
        }
        if (timer === 0) determineWinner({ player, enemy, timerId });
    }

    function aiLogic() {
        if (gameState !== 'PLAY') return;
        if (enemy.image === enemy.sprites.hit.image || enemy.image === enemy.sprites.death.image) return;
        
        if (finishHimActive && enemy.health <= 0) {
            enemy.velocity.x = 0;
            return; 
        }

        if (enemy.isAttacking) {
            enemy.velocity.x = 0;
            return;
        }

        const dx = player.position.x - enemy.position.x;
        const distance = Math.abs(dx);
        const moveSpeed = 4.5; 

        if (distance < 100 && Math.random() < 0.01) enemy.jump();

        if (distance > 80) {
            enemy.velocity.x = dx > 0 ? moveSpeed : -moveSpeed;
            enemy.switchSprite('run');
        } else {
            enemy.velocity.x = 0;
            const rand = Math.random();
            if (rand < 0.08) enemy.attack('attack1');
            else if (rand < 0.15) enemy.attack('attack2');
            else enemy.switchSprite('idle');
        }
    }

    function animate() {
        window.requestAnimationFrame(animate);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (gameBackground) gameBackground.update();
        if (crow) crow.update();

        if (fatalityPerformed || finishHimActive) {
             ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; 
             ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        if (gameState === 'MENU' || gameState.includes('_SELECT')) return;

        if (player.health > 0 && enemy.health > 0 && (gameState === 'PLAY' || gameState === 'PRE_FIGHT')) {
            if (player.position.x < enemy.position.x) {
                player.facing = 1; enemy.facing = -1;
            } else {
                player.facing = -1; enemy.facing = 1;
            }
        }

        player.update();
        enemy.update();

        const isPlayerAirborne = player.position.y + player.height < canvas.height - GROUND_HEIGHT - 10;
        const isEnemyAirborne = enemy.position.y + enemy.height < canvas.height - GROUND_HEIGHT - 10;
        
        if (!player.dead && !enemy.dead && !isPlayerAirborne && !isEnemyAirborne) {
             const pCenter = player.position.x + player.width/2;
             const eCenter = enemy.position.x + enemy.width/2;
             const dist = Math.abs(pCenter - eCenter);
             const minDist = 60; 
             if (dist < minDist && Math.abs(player.position.y - enemy.position.y) < 100) {
                 if (pCenter < eCenter) { player.position.x -= 2; enemy.position.x += 2; }
                 else { player.position.x += 2; enemy.position.x -= 2; }
             }
        }

        if (player.health > 0 && !finishHimActive) {
             if (player.velocity.x === 0 && player.velocity.y === 0) {
                 if (player.image !== player.sprites.hit.image && !player.isAttacking && (player.sprites.win && player.image !== player.sprites.win.image) && (player.sprites.fatality && player.image !== player.sprites.fatality.image)) {
                     if (!(player.sprites.start && player.image === player.sprites.start.image)) {
                        player.switchSprite('idle');
                     }
                 }
            } else if (player.velocity.y !== 0) {
                 player.switchSprite('jump');
            } else if (player.velocity.x !== 0) {
                 if (!player.isAttacking) player.switchSprite('run');
            }
        }

        if (enemy.health > 0 && enemy.velocity.y !== 0) {
            enemy.switchSprite('jump');
        }

        if (gameState === 'PLAY') {
            if (enemy.health <= 0 || player.health <= 0) {
                let currentWinnerWins = (enemy.health <= 0) ? playerWins : enemyWins;
                
                if (currentWinnerWins === 1 && !finishHimActive) {
                    triggerFinishHim();
                } else if (!finishHimActive) {
                    if (enemy.health <= 0) enemy.switchSprite('death');
                    if (player.health <= 0) player.switchSprite('death');
                    if (!koSoundPlayed) { playSound(AUDIO.ko); koSoundPlayed = true; }
                    determineWinner({ player, enemy, timerId });
                    gameState = 'ROUND_OVER';
                }
            }
            
            if (rectangularCollision({ rectangle1: player, rectangle2: enemy }) && player.isAttacking && player.framesCurrent >= 1) {
                player.isAttacking = false;
                if (finishHimActive && enemy.health <= 0) {
                    if (player.attackType === 'fatality') {
                         performFatality(player, enemy);
                    }
                } else {
                    let damage = player.attackType === 'attack2' ? 5 : 2;
                    enemy.health -= damage;
                    enemy.takeHit();
                    if (player.attackType === 'attack2') playSound(AUDIO.hitK); else playSound(AUDIO.hitP);
                    document.querySelector('#enemy-health').style.width = Math.max(0, enemy.health) + '%';
                }
            }
            
            if (rectangularCollision({ rectangle1: enemy, rectangle2: player }) && enemy.isAttacking && enemy.framesCurrent >= 1) {
                enemy.isAttacking = false;
                if (finishHimActive && player.health <= 0) {
                     // AI fatality? Not implemented
                } else {
                    player.health -= 5;
                    player.takeHit();
                    if (enemy.attackType === 'attack2') playSound(AUDIO.hitK); else playSound(AUDIO.hitP);
                    document.querySelector('#player-health').style.width = Math.max(0, player.health) + '%';
                }
            }
            
            aiLogic();
            
            player.velocity.x = 0;
            if (player.health > 0 && player.image !== player.sprites.hit.image && !player.isAttacking) {
                 if (!(player.sprites.start && player.image === player.sprites.start.image)) {
                    if (keys.a.pressed && player.lastKey === 'a') {
                        player.velocity.x = -5;
                    } else if (keys.d.pressed && player.lastKey === 'd') {
                        player.velocity.x = 5;
                    }
                }
            }
        }
    }

    animate();

    window.addEventListener('keydown', (event) => {
        if (gameState === 'GAMEOVER') {
             // Space removed, button handles it
            return;
        }

        if (gameState === 'PLAY') {
            if (player.health <= 0 && !finishHimActive) return;
            if (player.health <= 0) return;
            
            if (player.image === player.sprites.hit.image) return;
            
            const k = event.key.toLowerCase();
            
            if(k === 'n') {
                keys.n.pressed = true;
                if(finishHimActive && keys.m.pressed) player.attack('fatality');
                else player.attack('attack1');
            }
            else if(k === 'm') {
                keys.m.pressed = true;
                if(finishHimActive && keys.n.pressed) player.attack('fatality');
                else player.attack('attack2');
            }
            else {
                switch (k) {
                    case 'd': keys.d.pressed = true; player.lastKey = 'd'; break;
                    case 'a': keys.a.pressed = true; player.lastKey = 'a'; break;
                    case ' ': player.jump(); break;
                }
            }
        }
    });

    window.addEventListener('keyup', (event) => {
        switch (event.key.toLowerCase()) {
            case 'd': keys.d.pressed = false; break;
            case 'a': keys.a.pressed = false; break;
            case 'n': keys.n.pressed = false; break;
            case 'm': keys.m.pressed = false; break;
        }
    });
    
    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const btnJump = document.getElementById('btn-jump');
    const btnPunch = document.getElementById('btn-punch');
    const btnKick = document.getElementById('btn-kick');

    const handleTouch = (key, pressed) => {
        if (gameState !== 'PLAY') return;
        if(key === 'd') { keys.d.pressed = pressed; if(pressed) player.lastKey = 'd'; }
        if(key === 'a') { keys.a.pressed = pressed; if(pressed) player.lastKey = 'a'; }
        if(pressed) {
            if(key === 'space') player.jump();
            if(key === 'n') player.attack('attack1');
            if(key === 'm') player.attack('attack2');
        }
    };

    btnLeft.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleTouch('a', true); btnLeft.style.background='rgba(255,200,0,0.5)'; });
    btnLeft.addEventListener('touchend', (e)=>{ e.preventDefault(); handleTouch('a', false); btnLeft.style.background=''; });
    btnRight.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleTouch('d', true); btnRight.style.background='rgba(255,200,0,0.5)'; });
    btnRight.addEventListener('touchend', (e)=>{ e.preventDefault(); handleTouch('d', false); btnRight.style.background=''; });
    btnJump.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleTouch('space', true); });
    btnPunch.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleTouch('n', true); });
    btnKick.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleTouch('m', true); });

    const muteButton = document.getElementById('mute-btn');
    muteButton.addEventListener('click', (e) => {
        e.stopPropagation();
        AUDIO.music.muted = !AUDIO.music.muted;
        muteButton.innerHTML = AUDIO.music.muted ? 'ðŸ”‡' : 'ðŸ”Š';
        muteButton.style.borderColor = AUDIO.music.muted ? '#ff4444' : 'white';
    });

    showLayer('menu-main');

})(); // END IIFE
</script>
</body>
</html>

