<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Fighter Sprite (Walk / Punch / Kick)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0b0f;color:#eaeaf2;font-family:system-ui,Arial}
    header{padding:10px 14px;border-bottom:1px solid #222;opacity:.9;font-size:14px;line-height:1.35}
    kbd{background:#1b1b26;border:1px solid #2a2a3a;padding:2px 6px;border-radius:6px;font-size:12px}
    canvas{display:block;margin:0 auto;background:#12121a}
    .small{opacity:.7;font-size:12px;margin-top:6px}
  </style>
</head>
<body>
<header>
  P1: <kbd>A</kbd><kbd>D</kbd> jalan, <kbd>F</kbd> pukul, <kbd>G</kbd> tendang
  <br/>P2: <kbd>←</kbd><kbd>→</kbd> jalan, <kbd>/</kbd> pukul, <kbd>.</kbd> tendang
  <div class="small">Sprite: 128×150, 2 frame. Selalu menghadap lawan. (Punch masih pakai sprite walk)</div>
</header>

<canvas id="c" width="960" height="540"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // ====== SPRITE CONFIG ======
  const FRAME_W = 128;
  const FRAME_H = 150;
  const FRAMES = 2;

  // PAKAI RAW.GITHUBUSERCONTENT.COM (lebih stabil untuk canvas/CORS)
  const SPRITE_WALK_URL = "https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/Sprite-0003-Sheet.png";
  const SPRITE_KICK_URL = "https://raw.githubusercontent.com/fauzanbunz/hummingbird/main/kick.png";

  // ====== Helpers ======
  const keys = new Set();
  addEventListener("keydown", (e) => {
    keys.add(e.key);
    if (["ArrowLeft","ArrowRight"].includes(e.key)) e.preventDefault();
  });
  addEventListener("keyup", (e) => keys.delete(e.key));

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const overlap = (a,b)=>a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;

  const world = { w: canvas.width, h: canvas.height, groundY: canvas.height - 90 };

  const STATE = { IDLE:"idle", WALK:"walk", ATTACK:"attack" };

  function fighter(id, x) {
    return {
      id, x, y: world.groundY,
      vx: 0,
      facing: 1,
      state: STATE.IDLE,
      attack: null,
      atkT: 0,
      hitFreeze: 0,
      animT: 0,
      animFrame: 0
    };
  }

  // frame data sederhana (detik)
  const attacks = {
    punch: { startup: 0.10, active: 0.08, recovery: 0.18, range: 46, height: 26 },
    kick:  { startup: 0.14, active: 0.10, recovery: 0.22, range: 62, height: 30 }
  };

  // input buffer ringan
  const bufFrames = 8;
  const buf = { p1:{punch:0,kick:0}, p2:{punch:0,kick:0} };
  const press = (pid, btn) => buf[pid][btn] = bufFrames;
  const consume = (pid, btn) => {
    if (buf[pid][btn] > 0) { buf[pid][btn] = 0; return true; }
    return false;
  };

  addEventListener("keydown", (e) => {
    if (e.repeat) return;
    if (e.key === "f" || e.key === "F") press("p1","punch");
    if (e.key === "g" || e.key === "G") press("p1","kick");
    if (e.key === "/") press("p2","punch");
    if (e.key === ".") press("p2","kick");
  });

  function readControls(p) {
    if (p.id === "p1") {
      return {
        left: keys.has("a") || keys.has("A"),
        right: keys.has("d") || keys.has("D"),
        punch: consume("p1","punch"),
        kick: consume("p1","kick"),
      };
    }
    return {
      left: keys.has("ArrowLeft"),
      right: keys.has("ArrowRight"),
      punch: consume("p2","punch"),
      kick: consume("p2","kick"),
    };
  }

  function startAttack(p, type) {
    if (p.state === STATE.ATTACK) return;
    p.attack = attacks[type];
    p.atkT = 0;
    p.state = STATE.ATTACK;
    p.animT = 0;
    p.animFrame = 0;
  }

  function hurtbox(p) {
    return { x: p.x - 28, y: p.y - 120, w: 56, h: 120 };
  }

  function hitbox(p) {
    if (!p.attack) return null;
    const a = p.attack;
    const t = p.atkT;

    if (t < a.startup) return null;
    if (t > a.startup + a.active) return null;

    const hbW = a.range, hbH = a.height;
    const offsetX = 28 + (hbW/2) + 10;
    const cx = p.x + p.facing * offsetX;
    const cy = p.y - 90;
    return { x: cx - hbW/2, y: cy - hbH/2, w: hbW, h: hbH };
  }

  function updateFacing(p1, p2) {
    p1.facing = (p2.x >= p1.x) ? 1 : -1;
    p2.facing = (p1.x >= p2.x) ? 1 : -1;
  }

  function updateBuffers() {
    for (const pid of ["p1","p2"]) {
      buf[pid].punch = Math.max(0, buf[pid].punch - 1);
      buf[pid].kick  = Math.max(0, buf[pid].kick  - 1);
    }
  }

  function updateAnim(p, dt) {
    p.animT += dt;

    if (p.state === STATE.WALK) {
      const speed = 0.16;
      p.animFrame = Math.floor(p.animT / speed) % FRAMES;
      return;
    }

    if (p.state === STATE.IDLE) {
      p.animFrame = 0;
      return;
    }

    if (p.state === STATE.ATTACK && p.attack) {
      const total = p.attack.startup + p.attack.active + p.attack.recovery;
      p.animFrame = (p.atkT < total/2) ? 0 : 1;
    }
  }

  function updateFighter(p, other, dt) {
    if (p.hitFreeze > 0) {
      p.hitFreeze = Math.max(0, p.hitFreeze - dt);
      updateAnim(p, dt * 0.2);
      return;
    }

    if (p.state === STATE.ATTACK && p.attack) {
      p.atkT += dt;
      const total = p.attack.startup + p.attack.active + p.attack.recovery;
      if (p.atkT >= total) {
        p.attack = null;
        p.state = STATE.IDLE;
      }
      p.vx = 0;
    } else {
      const c = readControls(p);
      const speed = 320;
      let dir = 0;
      if (c.left) dir -= 1;
      if (c.right) dir += 1;

      p.vx = dir * speed;
      p.state = (dir !== 0) ? STATE.WALK : STATE.IDLE;

      if (c.punch) startAttack(p, "punch");
      else if (c.kick) startAttack(p, "kick");
    }

    p.x += p.vx * dt;
    p.x = clamp(p.x, 60, world.w - 60);

    // push kalau tumpuk
    const a = hurtbox(p), b = hurtbox(other);
    if (overlap(a,b)) {
      const sign = (p.x < other.x) ? -1 : 1;
      p.x += sign * 140 * dt;
      other.x -= sign * 140 * dt;
    }

    // hit detect
    const hb = hitbox(p);
    if (hb && overlap(hb, hurtbox(other))) {
      other.x += p.facing * 18;
      p.hitFreeze = 0.06;
      other.hitFreeze = 0.06;
      p.atkT = p.attack.startup + p.attack.active + 0.0001; // stop multi-hit
    }

    updateAnim(p, dt);
  }

  // ====== Rendering ======
  function drawGround() {
    ctx.clearRect(0,0,world.w,world.h);
    ctx.fillStyle = "#0e0e16";
    ctx.fillRect(0, world.groundY, world.w, world.h - world.groundY);
    ctx.strokeStyle = "#2a2a3a";
    ctx.beginPath();
    ctx.moveTo(0, world.groundY);
    ctx.lineTo(world.w, world.groundY);
    ctx.stroke();
  }

  function drawSprite(img, frameIndex, x, y, facing) {
    const sx = frameIndex * FRAME_W;
    const sy = 0;

    ctx.save();
    ctx.translate(x, y);

    if (facing === -1) ctx.scale(-1, 1);

    const dx = -FRAME_W / 2;
    const dy = -FRAME_H;

    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, sx, sy, FRAME_W, FRAME_H, dx, dy, FRAME_W, FRAME_H);
    ctx.restore();
  }

  function drawFallbackBox(p) {
    ctx.save();
    ctx.fillStyle = (p.id === "p1") ? "#8ae2ff" : "#ff9ac1";
    ctx.globalAlpha = (p.hitFreeze > 0) ? 0.6 : 1.0;
    ctx.fillRect(p.x - 30, p.y - 120, 60, 120);
    ctx.restore();
  }

  function drawDebug(p) {
    const hu = hurtbox(p);
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.strokeRect(hu.x, hu.y, hu.w, hu.h);

    const hi = hitbox(p);
    if (hi) {
      ctx.strokeStyle = "rgba(255,255,255,0.28)";
      ctx.strokeRect(hi.x, hi.y, hi.w, hi.h);
    }

    ctx.fillStyle = "rgba(234,234,242,0.75)";
    ctx.fillText(`${p.id.toUpperCase()} ${p.state}`, p.x - 50, p.y + 20);
  }

  function drawStatus(text) {
    ctx.fillStyle = "rgba(234,234,242,0.85)";
    ctx.fillText(text, 18, 26);
  }

  function loadImage(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error("Gagal load sprite: " + url));
      img.src = url;
    });
  }

  async function main() {
    ctx.font = "16px system-ui, Arial";
    drawGround();
    drawStatus("Loading sprite...");

    let walkImg = null, kickImg = null;
    let spriteOk = true;

    try {
      [walkImg, kickImg] = await Promise.all([
        loadImage(SPRITE_WALK_URL),
        loadImage(SPRITE_KICK_URL)
      ]);
    } catch (err) {
      spriteOk = false;
      console.error(err);
    }

    let p1 = fighter("p1", 280);
    let p2 = fighter("p2", 680);

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      updateBuffers();
      updateFacing(p1, p2);
      updateFighter(p1, p2, dt);
      updateFighter(p2, p1, dt);

      drawGround();
      ctx.font = "16px system-ui, Arial";

      if (!spriteOk) {
        drawStatus("Sprite gagal load. (Cek Console/URL). Fallback kotak aktif.");
        drawFallbackBox(p1);
        drawFallbackBox(p2);
      } else {
        // pilih sheet berdasarkan state
        const spriteFor = (p) => {
          if (p.state === STATE.ATTACK && p.attack) {
            if (p.attack === attacks.kick) return kickImg;
            return walkImg; // punch sementara walk
          }
          return walkImg;
        };

        drawSprite(spriteFor(p1), p1.animFrame, p1.x, p1.y, p1.facing);
        drawSprite(spriteFor(p2), p2.animFrame, p2.x, p2.y, p2.facing);
      }

      drawDebug(p1);
      drawDebug(p2);

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  }

  main();
})();
</script>
</body>
</html>
